{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\inetpub\\\\wwwroot\\\\ThesisProject\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst _require = require('stream'),\n      Transform = _require.Transform;\n\nconst _Buffer$from = Buffer.from('\\r'),\n      _Buffer$from2 = _slicedToArray(_Buffer$from, 1),\n      cr = _Buffer$from2[0];\n\nconst _Buffer$from3 = Buffer.from('\\n'),\n      _Buffer$from4 = _slicedToArray(_Buffer$from3, 1),\n      nl = _Buffer$from4[0];\n\nconst defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: ({\n    header\n  }) => header,\n  mapValues: ({\n    value\n  }) => value,\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false\n};\n\nclass CsvParser extends Transform {\n  constructor(opts = {}) {\n    super({\n      objectMode: true,\n      highWaterMark: 16\n    });\n    if (Array.isArray(opts)) opts = {\n      headers: opts\n    };\n    const options = Object.assign({}, defaults, opts);\n    options.customNewline = options.newline !== defaults.newline;\n\n    for (var _i = 0, _arr = ['newline', 'quote', 'separator']; _i < _arr.length; _i++) {\n      const key = _arr[_i];\n\n      if (typeof options[key] !== 'undefined') {\n        var _Buffer$from5 = Buffer.from(options[key]);\n\n        var _Buffer$from6 = _slicedToArray(_Buffer$from5, 1);\n\n        options[key] = _Buffer$from6[0];\n      }\n    } // if escape is not defined on the passed options, use the end value of quote\n\n\n    options.escape = (opts || {}).escape ? Buffer.from(options.escape)[0] : options.quote;\n    this.state = {\n      empty: options.raw ? Buffer.alloc(0) : '',\n      escaped: false,\n      first: true,\n      lineNumber: 0,\n      previousEnd: 0,\n      rowLength: 0,\n      quoted: false\n    };\n    this._prev = null;\n\n    if (options.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      options.strict = false;\n    }\n\n    if (options.headers || options.headers === false) {\n      this.state.first = false;\n    }\n\n    this.options = options;\n    this.headers = options.headers;\n  }\n\n  parseCell(buffer, start, end) {\n    const _this$options = this.options,\n          escape = _this$options.escape,\n          quote = _this$options.quote; // remove quotes from quoted cells\n\n    if (buffer[start] === quote && buffer[end - 1] === quote) {\n      start++;\n      end--;\n    }\n\n    let y = start;\n\n    for (let i = start; i < end; i++) {\n      // check for escape characters and skip them\n      if (buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote) {\n        i++;\n      }\n\n      if (y !== i) {\n        buffer[y] = buffer[i];\n      }\n\n      y++;\n    }\n\n    return this.parseValue(buffer, start, y);\n  }\n\n  parseLine(buffer, start, end) {\n    const _this$options2 = this.options,\n          customNewline = _this$options2.customNewline,\n          escape = _this$options2.escape,\n          mapHeaders = _this$options2.mapHeaders,\n          mapValues = _this$options2.mapValues,\n          quote = _this$options2.quote,\n          separator = _this$options2.separator,\n          skipComments = _this$options2.skipComments,\n          skipLines = _this$options2.skipLines;\n    end--; // trim newline\n\n    if (!customNewline && buffer.length && buffer[end - 1] === cr) {\n      end--;\n    }\n\n    const comma = separator;\n    const cells = [];\n    let isQuoted = false;\n    let offset = start;\n\n    if (skipComments) {\n      const char = typeof skipComments === 'string' ? skipComments : '#';\n\n      if (buffer[start] === Buffer.from(char)[0]) {\n        return;\n      }\n    }\n\n    const mapValue = value => {\n      if (this.state.first) {\n        return value;\n      }\n\n      const index = cells.length;\n      const header = this.headers[index];\n      return mapValues({\n        header,\n        index,\n        value\n      });\n    };\n\n    for (let i = start; i < end; i++) {\n      const isStartingQuote = !isQuoted && buffer[i] === quote;\n      const isEndingQuote = isQuoted && buffer[i] === quote && i + 1 <= end && buffer[i + 1] === comma;\n      const isEscape = isQuoted && buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote;\n\n      if (isStartingQuote || isEndingQuote) {\n        isQuoted = !isQuoted;\n        continue;\n      } else if (isEscape) {\n        i++;\n        continue;\n      }\n\n      if (buffer[i] === comma && !isQuoted) {\n        let value = this.parseCell(buffer, offset, i);\n        value = mapValue(value);\n        cells.push(value);\n        offset = i + 1;\n      }\n    }\n\n    if (offset < end) {\n      let value = this.parseCell(buffer, offset, end);\n      value = mapValue(value);\n      cells.push(value);\n    }\n\n    if (buffer[end - 1] === comma) {\n      cells.push(mapValue(this.state.empty));\n    }\n\n    const skip = skipLines && skipLines > this.state.lineNumber;\n    this.state.lineNumber++;\n\n    if (this.state.first && !skip) {\n      this.state.first = false;\n      this.headers = cells.map((header, index) => mapHeaders({\n        header,\n        index\n      }));\n      this.emit('headers', this.headers);\n      return;\n    }\n\n    if (!skip && this.options.strict && cells.length !== this.headers.length) {\n      const e = new RangeError('Row length does not match headers');\n      this.emit('error', e);\n    } else {\n      if (!skip) this.writeRow(cells);\n    }\n  }\n\n  parseValue(buffer, start, end) {\n    if (this.options.raw) {\n      return buffer.slice(start, end);\n    }\n\n    return buffer.toString('utf-8', start, end);\n  }\n\n  writeRow(cells) {\n    if (this.headers === false || cells.length > this.headers.length) {\n      this.headers = cells.map((value, index) => index);\n    }\n\n    const row = cells.reduce((o, cell, index) => {\n      const header = this.headers[index];\n\n      if (header !== null) {\n        o[header] = cell;\n      }\n\n      return o;\n    }, {});\n    this.push(row);\n  }\n\n  _flush(cb) {\n    if (this.state.escaped || !this._prev) return cb();\n    this.parseLine(this._prev, this.state.previousEnd, this._prev.length + 1); // plus since online -1s\n\n    cb();\n  }\n\n  _transform(data, enc, cb) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data);\n    }\n\n    const _this$options3 = this.options,\n          escape = _this$options3.escape,\n          quote = _this$options3.quote;\n    let start = 0;\n    let buffer = data;\n\n    if (this._prev) {\n      start = this._prev.length;\n      buffer = Buffer.concat([this._prev, data]);\n      this._prev = null;\n    }\n\n    const bufferLength = buffer.length;\n\n    for (let i = start; i < bufferLength; i++) {\n      const chr = buffer[i];\n      const nextChr = i + 1 < bufferLength ? buffer[i + 1] : null;\n      this.state.rowLength++;\n\n      if (this.state.rowLength > this.options.maxRowBytes) {\n        return cb(new Error('Row exceeds the maximum size'));\n      }\n\n      if (!this.state.escaped && chr === escape && nextChr === quote && i !== start) {\n        this.state.escaped = true;\n        continue;\n      } else if (chr === quote) {\n        if (this.state.escaped) {\n          this.state.escaped = false; // non-escaped quote (quoting the cell)\n        } else {\n          this.state.quoted = !this.state.quoted;\n        }\n\n        continue;\n      }\n\n      if (!this.state.quoted) {\n        if (this.state.first && !this.options.customNewline) {\n          if (chr === nl) {\n            this.options.newline = nl;\n          } else if (chr === cr) {\n            if (nextChr !== nl) {\n              this.options.newline = cr;\n            }\n          }\n        }\n\n        if (chr === this.options.newline) {\n          this.parseLine(buffer, this.state.previousEnd, i + 1);\n          this.state.previousEnd = i + 1;\n          this.state.rowLength = 0;\n        }\n      }\n    }\n\n    if (this.state.previousEnd === bufferLength) {\n      this.state.previousEnd = 0;\n      return cb();\n    }\n\n    if (bufferLength - this.state.previousEnd < data.length) {\n      this._prev = data;\n      this.state.previousEnd -= bufferLength - data.length;\n      return cb();\n    }\n\n    this._prev = buffer;\n    cb();\n  }\n\n}\n\nmodule.exports = opts => new CsvParser(opts);","map":{"version":3,"sources":["C:/inetpub/wwwroot/ThesisProject/node_modules/csv-parser/index.js"],"names":["require","Transform","Buffer","from","cr","nl","defaults","escape","headers","mapHeaders","header","mapValues","value","newline","quote","raw","separator","skipComments","skipLines","maxRowBytes","Number","MAX_SAFE_INTEGER","strict","CsvParser","constructor","opts","objectMode","highWaterMark","Array","isArray","options","Object","assign","customNewline","key","state","empty","alloc","escaped","first","lineNumber","previousEnd","rowLength","quoted","_prev","parseCell","buffer","start","end","y","i","parseValue","parseLine","length","comma","cells","isQuoted","offset","char","mapValue","index","isStartingQuote","isEndingQuote","isEscape","push","skip","map","emit","e","RangeError","writeRow","slice","toString","row","reduce","o","cell","_flush","cb","_transform","data","enc","concat","bufferLength","chr","nextChr","Error","module","exports"],"mappings":"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","sourcesContent":["const { Transform } = require('stream')\n\nconst [cr] = Buffer.from('\\r')\nconst [nl] = Buffer.from('\\n')\nconst defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: ({ header }) => header,\n  mapValues: ({ value }) => value,\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false\n}\n\nclass CsvParser extends Transform {\n  constructor (opts = {}) {\n    super({ objectMode: true, highWaterMark: 16 })\n\n    if (Array.isArray(opts)) opts = { headers: opts }\n\n    const options = Object.assign({}, defaults, opts)\n\n    options.customNewline = options.newline !== defaults.newline\n\n    for (const key of ['newline', 'quote', 'separator']) {\n      if (typeof options[key] !== 'undefined') {\n        ([options[key]] = Buffer.from(options[key]))\n      }\n    }\n\n    // if escape is not defined on the passed options, use the end value of quote\n    options.escape = (opts || {}).escape ? Buffer.from(options.escape)[0] : options.quote\n\n    this.state = {\n      empty: options.raw ? Buffer.alloc(0) : '',\n      escaped: false,\n      first: true,\n      lineNumber: 0,\n      previousEnd: 0,\n      rowLength: 0,\n      quoted: false\n    }\n\n    this._prev = null\n\n    if (options.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      options.strict = false\n    }\n\n    if (options.headers || options.headers === false) {\n      this.state.first = false\n    }\n\n    this.options = options\n    this.headers = options.headers\n  }\n\n  parseCell (buffer, start, end) {\n    const { escape, quote } = this.options\n    // remove quotes from quoted cells\n    if (buffer[start] === quote && buffer[end - 1] === quote) {\n      start++\n      end--\n    }\n\n    let y = start\n\n    for (let i = start; i < end; i++) {\n      // check for escape characters and skip them\n      if (buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote) {\n        i++\n      }\n\n      if (y !== i) {\n        buffer[y] = buffer[i]\n      }\n      y++\n    }\n\n    return this.parseValue(buffer, start, y)\n  }\n\n  parseLine (buffer, start, end) {\n    const { customNewline, escape, mapHeaders, mapValues, quote, separator, skipComments, skipLines } = this.options\n\n    end-- // trim newline\n    if (!customNewline && buffer.length && buffer[end - 1] === cr) {\n      end--\n    }\n\n    const comma = separator\n    const cells = []\n    let isQuoted = false\n    let offset = start\n\n    if (skipComments) {\n      const char = typeof skipComments === 'string' ? skipComments : '#'\n      if (buffer[start] === Buffer.from(char)[0]) {\n        return\n      }\n    }\n\n    const mapValue = (value) => {\n      if (this.state.first) {\n        return value\n      }\n\n      const index = cells.length\n      const header = this.headers[index]\n\n      return mapValues({ header, index, value })\n    }\n\n    for (let i = start; i < end; i++) {\n      const isStartingQuote = !isQuoted && buffer[i] === quote\n      const isEndingQuote = isQuoted && buffer[i] === quote && i + 1 <= end && buffer[i + 1] === comma\n      const isEscape = isQuoted && buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote\n\n      if (isStartingQuote || isEndingQuote) {\n        isQuoted = !isQuoted\n        continue\n      } else if (isEscape) {\n        i++\n        continue\n      }\n\n      if (buffer[i] === comma && !isQuoted) {\n        let value = this.parseCell(buffer, offset, i)\n        value = mapValue(value)\n        cells.push(value)\n        offset = i + 1\n      }\n    }\n\n    if (offset < end) {\n      let value = this.parseCell(buffer, offset, end)\n      value = mapValue(value)\n      cells.push(value)\n    }\n\n    if (buffer[end - 1] === comma) {\n      cells.push(mapValue(this.state.empty))\n    }\n\n    const skip = skipLines && skipLines > this.state.lineNumber\n    this.state.lineNumber++\n\n    if (this.state.first && !skip) {\n      this.state.first = false\n      this.headers = cells.map((header, index) => mapHeaders({ header, index }))\n\n      this.emit('headers', this.headers)\n      return\n    }\n\n    if (!skip && this.options.strict && cells.length !== this.headers.length) {\n      const e = new RangeError('Row length does not match headers')\n      this.emit('error', e)\n    } else {\n      if (!skip) this.writeRow(cells)\n    }\n  }\n\n  parseValue (buffer, start, end) {\n    if (this.options.raw) {\n      return buffer.slice(start, end)\n    }\n\n    return buffer.toString('utf-8', start, end)\n  }\n\n  writeRow (cells) {\n    if (this.headers === false || cells.length > this.headers.length) {\n      this.headers = cells.map((value, index) => index)\n    }\n\n    const row = cells.reduce((o, cell, index) => {\n      const header = this.headers[index]\n      if (header !== null) {\n        o[header] = cell\n      }\n      return o\n    }, {})\n\n    this.push(row)\n  }\n\n  _flush (cb) {\n    if (this.state.escaped || !this._prev) return cb()\n    this.parseLine(this._prev, this.state.previousEnd, this._prev.length + 1) // plus since online -1s\n    cb()\n  }\n\n  _transform (data, enc, cb) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data)\n    }\n\n    const { escape, quote } = this.options\n    let start = 0\n    let buffer = data\n\n    if (this._prev) {\n      start = this._prev.length\n      buffer = Buffer.concat([this._prev, data])\n      this._prev = null\n    }\n\n    const bufferLength = buffer.length\n\n    for (let i = start; i < bufferLength; i++) {\n      const chr = buffer[i]\n      const nextChr = i + 1 < bufferLength ? buffer[i + 1] : null\n\n      this.state.rowLength++\n      if (this.state.rowLength > this.options.maxRowBytes) {\n        return cb(new Error('Row exceeds the maximum size'))\n      }\n\n      if (!this.state.escaped && chr === escape && nextChr === quote && i !== start) {\n        this.state.escaped = true\n        continue\n      } else if (chr === quote) {\n        if (this.state.escaped) {\n          this.state.escaped = false\n          // non-escaped quote (quoting the cell)\n        } else {\n          this.state.quoted = !this.state.quoted\n        }\n        continue\n      }\n\n      if (!this.state.quoted) {\n        if (this.state.first && !this.options.customNewline) {\n          if (chr === nl) {\n            this.options.newline = nl\n          } else if (chr === cr) {\n            if (nextChr !== nl) {\n              this.options.newline = cr\n            }\n          }\n        }\n\n        if (chr === this.options.newline) {\n          this.parseLine(buffer, this.state.previousEnd, i + 1)\n          this.state.previousEnd = i + 1\n          this.state.rowLength = 0\n        }\n      }\n    }\n\n    if (this.state.previousEnd === bufferLength) {\n      this.state.previousEnd = 0\n      return cb()\n    }\n\n    if (bufferLength - this.state.previousEnd < data.length) {\n      this._prev = data\n      this.state.previousEnd -= (bufferLength - data.length)\n      return cb()\n    }\n\n    this._prev = buffer\n    cb()\n  }\n}\n\nmodule.exports = (opts) => new CsvParser(opts)\n"]},"metadata":{},"sourceType":"script"}