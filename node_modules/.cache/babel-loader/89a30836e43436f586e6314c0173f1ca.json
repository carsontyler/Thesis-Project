{"ast":null,"code":"var Parser = require('./Parser');\n\nvar Sequences = require('./sequences');\n\nvar Packets = require('./packets');\n\nvar Stream = require('stream').Stream;\n\nvar Util = require('util');\n\nvar PacketWriter = require('./PacketWriter');\n\nmodule.exports = Protocol;\nUtil.inherits(Protocol, Stream);\n\nfunction Protocol(options) {\n  Stream.call(this);\n  options = options || {};\n  this.readable = true;\n  this.writable = true;\n  this._config = options.config || {};\n  this._connection = options.connection;\n  this._callback = null;\n  this._fatalError = null;\n  this._quitSequence = null;\n  this._handshake = false;\n  this._handshaked = false;\n  this._ended = false;\n  this._destroyed = false;\n  this._queue = [];\n  this._handshakeInitializationPacket = null;\n  this._parser = new Parser({\n    onError: this.handleParserError.bind(this),\n    onPacket: this._parsePacket.bind(this),\n    config: this._config\n  });\n}\n\nProtocol.prototype.write = function (buffer) {\n  this._parser.write(buffer);\n\n  return true;\n};\n\nProtocol.prototype.handshake = function handshake(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.config = this._config;\n\n  var sequence = this._enqueue(new Sequences.Handshake(options, callback));\n\n  this._handshake = true;\n  return sequence;\n};\n\nProtocol.prototype.query = function query(options, callback) {\n  return this._enqueue(new Sequences.Query(options, callback));\n};\n\nProtocol.prototype.changeUser = function changeUser(options, callback) {\n  return this._enqueue(new Sequences.ChangeUser(options, callback));\n};\n\nProtocol.prototype.ping = function ping(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  return this._enqueue(new Sequences.Ping(options, callback));\n};\n\nProtocol.prototype.stats = function stats(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  return this._enqueue(new Sequences.Statistics(options, callback));\n};\n\nProtocol.prototype.quit = function quit(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var self = this;\n\n  var sequence = this._enqueue(new Sequences.Quit(options, callback));\n\n  sequence.on('end', function () {\n    self.end();\n  });\n  return this._quitSequence = sequence;\n};\n\nProtocol.prototype.end = function () {\n  if (this._ended) {\n    return;\n  }\n\n  this._ended = true;\n\n  if (this._quitSequence && (this._quitSequence._ended || this._queue[0] === this._quitSequence)) {\n    this._quitSequence.end();\n\n    this.emit('end');\n    return;\n  }\n\n  var err = new Error('Connection lost: The server closed the connection.');\n  err.fatal = true;\n  err.code = 'PROTOCOL_CONNECTION_LOST';\n\n  this._delegateError(err);\n};\n\nProtocol.prototype.pause = function () {\n  this._parser.pause(); // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n\n\n  var seq = this._queue[0];\n\n  if (seq && seq.emit) {\n    seq.emit('pause');\n  }\n};\n\nProtocol.prototype.resume = function () {\n  this._parser.resume(); // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n\n\n  var seq = this._queue[0];\n\n  if (seq && seq.emit) {\n    seq.emit('resume');\n  }\n};\n\nProtocol.prototype._enqueue = function (sequence) {\n  if (!this._validateEnqueue(sequence)) {\n    return sequence;\n  }\n\n  if (this._config.trace) {\n    // Long stack trace support\n    sequence._callSite = sequence._callSite || new Error();\n  }\n\n  this._queue.push(sequence);\n\n  this.emit('enqueue', sequence);\n  var self = this;\n  sequence.on('error', function (err) {\n    self._delegateError(err, sequence);\n  }).on('packet', function (packet) {\n    sequence._timer.active();\n\n    self._emitPacket(packet);\n  }).on('timeout', function () {\n    var err = new Error(sequence.constructor.name + ' inactivity timeout');\n    err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';\n    err.fatal = true;\n    err.timeout = sequence._timeout;\n\n    self._delegateError(err, sequence);\n  });\n\n  if (sequence.constructor === Sequences.Handshake) {\n    sequence.on('start-tls', function () {\n      sequence._timer.active();\n\n      self._connection._startTLS(function (err) {\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          sequence.end(err);\n          return;\n        }\n\n        sequence._timer.active();\n\n        sequence._tlsUpgradeCompleteHandler();\n      });\n    });\n    sequence.on('end', function () {\n      self._handshaked = true;\n\n      if (!self._fatalError) {\n        self.emit('handshake', self._handshakeInitializationPacket);\n      }\n    });\n  }\n\n  sequence.on('end', function () {\n    self._dequeue(sequence);\n  });\n\n  if (this._queue.length === 1) {\n    this._parser.resetPacketNumber();\n\n    this._startSequence(sequence);\n  }\n\n  return sequence;\n};\n\nProtocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {\n  var err;\n  var prefix = 'Cannot enqueue ' + sequence.constructor.name;\n\n  if (this._fatalError) {\n    err = new Error(prefix + ' after fatal error.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR';\n  } else if (this._quitSequence) {\n    err = new Error(prefix + ' after invoking quit.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_QUIT';\n  } else if (this._destroyed) {\n    err = new Error(prefix + ' after being destroyed.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_DESTROY';\n  } else if ((this._handshake || this._handshaked) && sequence.constructor === Sequences.Handshake) {\n    err = new Error(prefix + ' after already enqueuing a Handshake.');\n    err.code = 'PROTOCOL_ENQUEUE_HANDSHAKE_TWICE';\n  } else {\n    return true;\n  }\n\n  var self = this;\n  err.fatal = false; // add error handler\n\n  sequence.on('error', function (err) {\n    self._delegateError(err, sequence);\n  });\n  process.nextTick(function () {\n    sequence.end(err);\n  });\n  return false;\n};\n\nProtocol.prototype._parsePacket = function () {\n  var sequence = this._queue[0];\n\n  if (!sequence) {\n    var err = new Error('Received packet with no active sequence.');\n    err.code = 'PROTOCOL_STRAY_PACKET';\n    err.fatal = true;\n\n    this._delegateError(err);\n\n    return;\n  }\n\n  var Packet = this._determinePacket(sequence);\n\n  var packet = new Packet({\n    protocol41: this._config.protocol41\n  });\n  var packetName = Packet.name; // Special case: Faster dispatch, and parsing done inside sequence\n\n  if (Packet === Packets.RowDataPacket) {\n    sequence.RowDataPacket(packet, this._parser, this._connection);\n\n    if (this._config.debug) {\n      this._debugPacket(true, packet);\n    }\n\n    return;\n  }\n\n  if (this._config.debug) {\n    this._parsePacketDebug(packet);\n  } else {\n    packet.parse(this._parser);\n  }\n\n  if (Packet === Packets.HandshakeInitializationPacket) {\n    this._handshakeInitializationPacket = packet;\n    this.emit('initialize', packet);\n  }\n\n  sequence._timer.active();\n\n  if (!sequence[packetName]) {\n    var err = new Error('Received packet in the wrong sequence.');\n    err.code = 'PROTOCOL_INCORRECT_PACKET_SEQUENCE';\n    err.fatal = true;\n\n    this._delegateError(err);\n\n    return;\n  }\n\n  sequence[packetName](packet);\n};\n\nProtocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {\n  try {\n    packet.parse(this._parser);\n  } finally {\n    this._debugPacket(true, packet);\n  }\n};\n\nProtocol.prototype._emitPacket = function (packet) {\n  var packetWriter = new PacketWriter();\n  packet.write(packetWriter);\n  this.emit('data', packetWriter.toBuffer(this._parser));\n\n  if (this._config.debug) {\n    this._debugPacket(false, packet);\n  }\n};\n\nProtocol.prototype._determinePacket = function (sequence) {\n  var firstByte = this._parser.peak();\n\n  if (sequence.determinePacket) {\n    var Packet = sequence.determinePacket(firstByte, this._parser);\n\n    if (Packet) {\n      return Packet;\n    }\n  }\n\n  switch (firstByte) {\n    case 0x00:\n      return Packets.OkPacket;\n\n    case 0xfe:\n      return Packets.EofPacket;\n\n    case 0xff:\n      return Packets.ErrorPacket;\n  }\n\n  throw new Error('Could not determine packet, firstByte = ' + firstByte);\n};\n\nProtocol.prototype._dequeue = function (sequence) {\n  sequence._timer.stop(); // No point in advancing the queue, we are dead\n\n\n  if (this._fatalError) {\n    return;\n  }\n\n  this._queue.shift();\n\n  var sequence = this._queue[0];\n\n  if (!sequence) {\n    this.emit('drain');\n    return;\n  }\n\n  this._parser.resetPacketNumber();\n\n  this._startSequence(sequence);\n};\n\nProtocol.prototype._startSequence = function (sequence) {\n  if (sequence._timeout > 0 && isFinite(sequence._timeout)) {\n    sequence._timer.start(sequence._timeout);\n  }\n\n  if (sequence.constructor === Sequences.ChangeUser) {\n    sequence.start(this._handshakeInitializationPacket);\n  } else {\n    sequence.start();\n  }\n};\n\nProtocol.prototype.handleNetworkError = function (err) {\n  err.fatal = true;\n  var sequence = this._queue[0];\n\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\n\nProtocol.prototype.handleParserError = function handleParserError(err) {\n  var sequence = this._queue[0];\n\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\n\nProtocol.prototype._delegateError = function (err, sequence) {\n  // Stop delegating errors after the first fatal error\n  if (this._fatalError) {\n    return;\n  }\n\n  if (err.fatal) {\n    this._fatalError = err;\n  }\n\n  if (this._shouldErrorBubbleUp(err, sequence)) {\n    // Can't use regular 'error' event here as that always destroys the pipe\n    // between socket and protocol which is not what we want (unless the\n    // exception was fatal).\n    this.emit('unhandledError', err);\n  } else if (err.fatal) {\n    // Send fatal error to all sequences in the queue\n    var queue = this._queue;\n    process.nextTick(function () {\n      queue.forEach(function (sequence) {\n        sequence.end(err);\n      });\n      queue.length = 0;\n    });\n  } // Make sure the stream we are piping to is getting closed\n\n\n  if (err.fatal) {\n    this.emit('end', err);\n  }\n};\n\nProtocol.prototype._shouldErrorBubbleUp = function (err, sequence) {\n  if (sequence) {\n    if (sequence.hasErrorHandler()) {\n      return false;\n    } else if (!err.fatal) {\n      return true;\n    }\n  }\n\n  return err.fatal && !this._hasPendingErrorHandlers();\n};\n\nProtocol.prototype._hasPendingErrorHandlers = function () {\n  return this._queue.some(function (sequence) {\n    return sequence.hasErrorHandler();\n  });\n};\n\nProtocol.prototype.destroy = function () {\n  this._destroyed = true;\n\n  this._parser.pause();\n\n  if (this._connection.state !== 'disconnected') {\n    if (!this._ended) {\n      this.end();\n    }\n  }\n};\n\nProtocol.prototype._debugPacket = function (incoming, packet) {\n  var connection = this._connection;\n  var direction = incoming ? '<--' : '-->';\n  var packetName = packet.constructor.name;\n  var threadId = connection && connection.threadId !== null ? ' (' + connection.threadId + ')' : ''; // check for debug packet restriction\n\n  if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packetName) === -1) {\n    return;\n  }\n\n  var packetPayload = Util.inspect(packet).replace(/^[^{]+/, '');\n  console.log('%s%s %s %s\\n', direction, threadId, packetName, packetPayload);\n};","map":{"version":3,"sources":["C:/inetpub/wwwroot/ThesisProject/node_modules/mysql/lib/protocol/Protocol.js"],"names":["Parser","require","Sequences","Packets","Stream","Util","PacketWriter","module","exports","Protocol","inherits","options","call","readable","writable","_config","config","_connection","connection","_callback","_fatalError","_quitSequence","_handshake","_handshaked","_ended","_destroyed","_queue","_handshakeInitializationPacket","_parser","onError","handleParserError","bind","onPacket","_parsePacket","prototype","write","buffer","handshake","callback","sequence","_enqueue","Handshake","query","Query","changeUser","ChangeUser","ping","Ping","stats","Statistics","quit","self","Quit","on","end","emit","err","Error","fatal","code","_delegateError","pause","seq","resume","_validateEnqueue","trace","_callSite","push","packet","_timer","active","_emitPacket","constructor","name","timeout","_timeout","_startTLS","_tlsUpgradeCompleteHandler","_dequeue","length","resetPacketNumber","_startSequence","prefix","process","nextTick","Packet","_determinePacket","protocol41","packetName","RowDataPacket","debug","_debugPacket","_parsePacketDebug","parse","HandshakeInitializationPacket","packetWriter","toBuffer","firstByte","peak","determinePacket","OkPacket","EofPacket","ErrorPacket","stop","shift","isFinite","start","handleNetworkError","_shouldErrorBubbleUp","queue","forEach","hasErrorHandler","_hasPendingErrorHandlers","some","destroy","state","incoming","direction","threadId","Array","isArray","indexOf","packetPayload","inspect","replace","console","log"],"mappings":"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","sourcesContent":["var Parser       = require('./Parser');\r\nvar Sequences    = require('./sequences');\r\nvar Packets      = require('./packets');\r\nvar Stream       = require('stream').Stream;\r\nvar Util         = require('util');\r\nvar PacketWriter = require('./PacketWriter');\r\n\r\nmodule.exports = Protocol;\r\nUtil.inherits(Protocol, Stream);\r\nfunction Protocol(options) {\r\n  Stream.call(this);\r\n\r\n  options = options || {};\r\n\r\n  this.readable = true;\r\n  this.writable = true;\r\n\r\n  this._config                        = options.config || {};\r\n  this._connection                    = options.connection;\r\n  this._callback                      = null;\r\n  this._fatalError                    = null;\r\n  this._quitSequence                  = null;\r\n  this._handshake                     = false;\r\n  this._handshaked                    = false;\r\n  this._ended                         = false;\r\n  this._destroyed                     = false;\r\n  this._queue                         = [];\r\n  this._handshakeInitializationPacket = null;\r\n\r\n  this._parser = new Parser({\r\n    onError  : this.handleParserError.bind(this),\r\n    onPacket : this._parsePacket.bind(this),\r\n    config   : this._config\r\n  });\r\n}\r\n\r\nProtocol.prototype.write = function(buffer) {\r\n  this._parser.write(buffer);\r\n  return true;\r\n};\r\n\r\nProtocol.prototype.handshake = function handshake(options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  options = options || {};\r\n  options.config = this._config;\r\n\r\n  var sequence = this._enqueue(new Sequences.Handshake(options, callback));\r\n\r\n  this._handshake = true;\r\n\r\n  return sequence;\r\n};\r\n\r\nProtocol.prototype.query = function query(options, callback) {\r\n  return this._enqueue(new Sequences.Query(options, callback));\r\n};\r\n\r\nProtocol.prototype.changeUser = function changeUser(options, callback) {\r\n  return this._enqueue(new Sequences.ChangeUser(options, callback));\r\n};\r\n\r\nProtocol.prototype.ping = function ping(options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  return this._enqueue(new Sequences.Ping(options, callback));\r\n};\r\n\r\nProtocol.prototype.stats = function stats(options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  return this._enqueue(new Sequences.Statistics(options, callback));\r\n};\r\n\r\nProtocol.prototype.quit = function quit(options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  var self     = this;\r\n  var sequence = this._enqueue(new Sequences.Quit(options, callback));\r\n\r\n  sequence.on('end', function () {\r\n    self.end();\r\n  });\r\n\r\n  return this._quitSequence = sequence;\r\n};\r\n\r\nProtocol.prototype.end = function() {\r\n  if (this._ended) {\r\n    return;\r\n  }\r\n  this._ended = true;\r\n\r\n  if (this._quitSequence && (this._quitSequence._ended || this._queue[0] === this._quitSequence)) {\r\n    this._quitSequence.end();\r\n    this.emit('end');\r\n    return;\r\n  }\r\n\r\n  var err = new Error('Connection lost: The server closed the connection.');\r\n  err.fatal = true;\r\n  err.code = 'PROTOCOL_CONNECTION_LOST';\r\n\r\n  this._delegateError(err);\r\n};\r\n\r\nProtocol.prototype.pause = function() {\r\n  this._parser.pause();\r\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\r\n  var seq = this._queue[0];\r\n  if (seq && seq.emit) {\r\n    seq.emit('pause');\r\n  }\r\n};\r\n\r\nProtocol.prototype.resume = function() {\r\n  this._parser.resume();\r\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\r\n  var seq = this._queue[0];\r\n  if (seq && seq.emit) {\r\n    seq.emit('resume');\r\n  }\r\n};\r\n\r\nProtocol.prototype._enqueue = function(sequence) {\r\n  if (!this._validateEnqueue(sequence)) {\r\n    return sequence;\r\n  }\r\n\r\n  if (this._config.trace) {\r\n    // Long stack trace support\r\n    sequence._callSite = sequence._callSite || new Error();\r\n  }\r\n\r\n  this._queue.push(sequence);\r\n  this.emit('enqueue', sequence);\r\n\r\n  var self = this;\r\n  sequence\r\n    .on('error', function(err) {\r\n      self._delegateError(err, sequence);\r\n    })\r\n    .on('packet', function(packet) {\r\n      sequence._timer.active();\r\n      self._emitPacket(packet);\r\n    })\r\n    .on('timeout', function() {\r\n      var err = new Error(sequence.constructor.name + ' inactivity timeout');\r\n\r\n      err.code    = 'PROTOCOL_SEQUENCE_TIMEOUT';\r\n      err.fatal   = true;\r\n      err.timeout = sequence._timeout;\r\n\r\n      self._delegateError(err, sequence);\r\n    });\r\n\r\n  if (sequence.constructor === Sequences.Handshake) {\r\n    sequence.on('start-tls', function () {\r\n      sequence._timer.active();\r\n      self._connection._startTLS(function(err) {\r\n        if (err) {\r\n          // SSL negotiation error are fatal\r\n          err.code  = 'HANDSHAKE_SSL_ERROR';\r\n          err.fatal = true;\r\n          sequence.end(err);\r\n          return;\r\n        }\r\n\r\n        sequence._timer.active();\r\n        sequence._tlsUpgradeCompleteHandler();\r\n      });\r\n    });\r\n\r\n    sequence.on('end', function () {\r\n      self._handshaked = true;\r\n\r\n      if (!self._fatalError) {\r\n        self.emit('handshake', self._handshakeInitializationPacket);\r\n      }\r\n    });\r\n  }\r\n\r\n  sequence.on('end', function () {\r\n    self._dequeue(sequence);\r\n  });\r\n\r\n  if (this._queue.length === 1) {\r\n    this._parser.resetPacketNumber();\r\n    this._startSequence(sequence);\r\n  }\r\n\r\n  return sequence;\r\n};\r\n\r\nProtocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {\r\n  var err;\r\n  var prefix = 'Cannot enqueue ' + sequence.constructor.name;\r\n\r\n  if (this._fatalError) {\r\n    err      = new Error(prefix + ' after fatal error.');\r\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR';\r\n  } else if (this._quitSequence) {\r\n    err      = new Error(prefix + ' after invoking quit.');\r\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_QUIT';\r\n  } else if (this._destroyed) {\r\n    err      = new Error(prefix + ' after being destroyed.');\r\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_DESTROY';\r\n  } else if ((this._handshake || this._handshaked) && sequence.constructor === Sequences.Handshake) {\r\n    err      = new Error(prefix + ' after already enqueuing a Handshake.');\r\n    err.code = 'PROTOCOL_ENQUEUE_HANDSHAKE_TWICE';\r\n  } else {\r\n    return true;\r\n  }\r\n\r\n  var self  = this;\r\n  err.fatal = false;\r\n\r\n  // add error handler\r\n  sequence.on('error', function (err) {\r\n    self._delegateError(err, sequence);\r\n  });\r\n\r\n  process.nextTick(function () {\r\n    sequence.end(err);\r\n  });\r\n\r\n  return false;\r\n};\r\n\r\nProtocol.prototype._parsePacket = function() {\r\n  var sequence = this._queue[0];\r\n\r\n  if (!sequence) {\r\n    var err   = new Error('Received packet with no active sequence.');\r\n    err.code  = 'PROTOCOL_STRAY_PACKET';\r\n    err.fatal = true;\r\n\r\n    this._delegateError(err);\r\n    return;\r\n  }\r\n\r\n  var Packet     = this._determinePacket(sequence);\r\n  var packet     = new Packet({protocol41: this._config.protocol41});\r\n  var packetName = Packet.name;\r\n\r\n  // Special case: Faster dispatch, and parsing done inside sequence\r\n  if (Packet === Packets.RowDataPacket) {\r\n    sequence.RowDataPacket(packet, this._parser, this._connection);\r\n\r\n    if (this._config.debug) {\r\n      this._debugPacket(true, packet);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  if (this._config.debug) {\r\n    this._parsePacketDebug(packet);\r\n  } else {\r\n    packet.parse(this._parser);\r\n  }\r\n\r\n  if (Packet === Packets.HandshakeInitializationPacket) {\r\n    this._handshakeInitializationPacket = packet;\r\n    this.emit('initialize', packet);\r\n  }\r\n\r\n  sequence._timer.active();\r\n\r\n  if (!sequence[packetName]) {\r\n    var err   = new Error('Received packet in the wrong sequence.');\r\n    err.code  = 'PROTOCOL_INCORRECT_PACKET_SEQUENCE';\r\n    err.fatal = true;\r\n\r\n    this._delegateError(err);\r\n    return;\r\n  }\r\n\r\n  sequence[packetName](packet);\r\n};\r\n\r\nProtocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {\r\n  try {\r\n    packet.parse(this._parser);\r\n  } finally {\r\n    this._debugPacket(true, packet);\r\n  }\r\n};\r\n\r\nProtocol.prototype._emitPacket = function(packet) {\r\n  var packetWriter = new PacketWriter();\r\n  packet.write(packetWriter);\r\n  this.emit('data', packetWriter.toBuffer(this._parser));\r\n\r\n  if (this._config.debug) {\r\n    this._debugPacket(false, packet);\r\n  }\r\n};\r\n\r\nProtocol.prototype._determinePacket = function(sequence) {\r\n  var firstByte = this._parser.peak();\r\n\r\n  if (sequence.determinePacket) {\r\n    var Packet = sequence.determinePacket(firstByte, this._parser);\r\n    if (Packet) {\r\n      return Packet;\r\n    }\r\n  }\r\n\r\n  switch (firstByte) {\r\n    case 0x00: return Packets.OkPacket;\r\n    case 0xfe: return Packets.EofPacket;\r\n    case 0xff: return Packets.ErrorPacket;\r\n  }\r\n\r\n  throw new Error('Could not determine packet, firstByte = ' + firstByte);\r\n};\r\n\r\nProtocol.prototype._dequeue = function(sequence) {\r\n  sequence._timer.stop();\r\n\r\n  // No point in advancing the queue, we are dead\r\n  if (this._fatalError) {\r\n    return;\r\n  }\r\n\r\n  this._queue.shift();\r\n\r\n  var sequence = this._queue[0];\r\n  if (!sequence) {\r\n    this.emit('drain');\r\n    return;\r\n  }\r\n\r\n  this._parser.resetPacketNumber();\r\n\r\n  this._startSequence(sequence);\r\n};\r\n\r\nProtocol.prototype._startSequence = function(sequence) {\r\n  if (sequence._timeout > 0 && isFinite(sequence._timeout)) {\r\n    sequence._timer.start(sequence._timeout);\r\n  }\r\n\r\n  if (sequence.constructor === Sequences.ChangeUser) {\r\n    sequence.start(this._handshakeInitializationPacket);\r\n  } else {\r\n    sequence.start();\r\n  }\r\n};\r\n\r\nProtocol.prototype.handleNetworkError = function(err) {\r\n  err.fatal = true;\r\n\r\n  var sequence = this._queue[0];\r\n  if (sequence) {\r\n    sequence.end(err);\r\n  } else {\r\n    this._delegateError(err);\r\n  }\r\n};\r\n\r\nProtocol.prototype.handleParserError = function handleParserError(err) {\r\n  var sequence = this._queue[0];\r\n  if (sequence) {\r\n    sequence.end(err);\r\n  } else {\r\n    this._delegateError(err);\r\n  }\r\n};\r\n\r\nProtocol.prototype._delegateError = function(err, sequence) {\r\n  // Stop delegating errors after the first fatal error\r\n  if (this._fatalError) {\r\n    return;\r\n  }\r\n\r\n  if (err.fatal) {\r\n    this._fatalError = err;\r\n  }\r\n\r\n  if (this._shouldErrorBubbleUp(err, sequence)) {\r\n    // Can't use regular 'error' event here as that always destroys the pipe\r\n    // between socket and protocol which is not what we want (unless the\r\n    // exception was fatal).\r\n    this.emit('unhandledError', err);\r\n  } else if (err.fatal) {\r\n    // Send fatal error to all sequences in the queue\r\n    var queue = this._queue;\r\n    process.nextTick(function () {\r\n      queue.forEach(function (sequence) {\r\n        sequence.end(err);\r\n      });\r\n      queue.length = 0;\r\n    });\r\n  }\r\n\r\n  // Make sure the stream we are piping to is getting closed\r\n  if (err.fatal) {\r\n    this.emit('end', err);\r\n  }\r\n};\r\n\r\nProtocol.prototype._shouldErrorBubbleUp = function(err, sequence) {\r\n  if (sequence) {\r\n    if (sequence.hasErrorHandler()) {\r\n      return false;\r\n    } else if (!err.fatal) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return (err.fatal && !this._hasPendingErrorHandlers());\r\n};\r\n\r\nProtocol.prototype._hasPendingErrorHandlers = function() {\r\n  return this._queue.some(function(sequence) {\r\n    return sequence.hasErrorHandler();\r\n  });\r\n};\r\n\r\nProtocol.prototype.destroy = function() {\r\n  this._destroyed = true;\r\n  this._parser.pause();\r\n\r\n  if (this._connection.state !== 'disconnected') {\r\n    if (!this._ended) {\r\n      this.end();\r\n    }\r\n  }\r\n};\r\n\r\nProtocol.prototype._debugPacket = function(incoming, packet) {\r\n  var connection = this._connection;\r\n  var direction  = incoming\r\n    ? '<--'\r\n    : '-->';\r\n  var packetName = packet.constructor.name;\r\n  var threadId   = connection && connection.threadId !== null\r\n    ? ' (' + connection.threadId + ')'\r\n    : '';\r\n\r\n  // check for debug packet restriction\r\n  if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packetName) === -1) {\r\n    return;\r\n  }\r\n\r\n  var packetPayload = Util.inspect(packet).replace(/^[^{]+/, '');\r\n\r\n  console.log('%s%s %s %s\\n', direction, threadId, packetName, packetPayload);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}